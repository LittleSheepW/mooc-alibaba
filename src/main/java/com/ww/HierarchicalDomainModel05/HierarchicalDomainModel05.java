package com.ww.HierarchicalDomainModel05;

/**
 * @author: Sun
 * @create: 2019-11-15 12:06
 * @version: v1.0
 */
public class HierarchicalDomainModel05 {

    /**
     *【参考】分层领域模型规约
     * DO (Data Object):此对象与数据库表结构一一对应，通过DAO层向上传输数据源对象。
     * DTO (Data Transfer Object): 数据传输对象，Service 或Manager向外传输的对象。
     * BO (Business Object):业务对象，由Service层输出的封装业务逻辑的对象。
     * AO (Application Object):应用对象，在Web层与Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
     * VO (View Object):显示层对象，通常是Web向模板渲染引擎层传输的对象。
     * Query: 数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。
     */

    /**
     * 整理+补充：
     * DTO(Data Transfer Object)：数据传输对象，通常用于Service和Manager层向上层传递。不提倡在DTO中写逻辑，强制不要在RPC返回对象的DTO中封装逻辑。
     * Param/Query：查询参数对象，适用于各层，通常用作接受前端参数对象。在Service调用DAO时封装为Query对象传入，如果需要查询其他依赖则需要封装Param对象作为参数去查询。DAO 层一般插入和更新的参数对象使用DO或Param, 查询参数一般使用Query，删除参数一般使用Param。
     * BO(Business Object)：业务对象，该对象中通常包含业务逻辑，有的团队当做Service层内保存中间信息数据的“DTO”或者上下文对象来使用。(BO中可以保存中间状态，放一些逻辑等，这些并不适合放在DTO中)
     * VO(View Object)：视图对象，通常作为控制层通过JSON返回给前端然后前端渲染或者加载页面模板在后端进行填充。
     * AO (Application Object)：应用对象。通常用在控制层和服务层之间。有些团队会将前端查询的属性和保存的属性几乎一致的对象封装为AO，如读取用户属性后传递给前端，用户在前端编辑了用户属性后传回后端。这种用法将AO用作Param和VO 或 Param和DTO的组合。
     *
     * 即使同一个接口，但是一个对内使用，一个对外暴露，尽量使用不同接口，定义不同的参数和返回值，从而避免因为修改内部或外部的数据结构而
     * 导致另外一个受到影响，这也是单一职责原则的要求。
     */

    /**
     * 本节问题：
     * 1、为什么需要这些分层领域模型?
     * 答案：使用不同的分层领域模型能够让程序更加健壮、更容易拓展，可以降低系统各层的耦合度。
     *
     * 分层模型的优势只有在系统较大时才体现得更加明显。设想一下如果我们不想定义DTO和VO，直接将DO用到数据访问层、服务层、控制层和外部访问
     * 接口上。此时该表删除或者修改一个字段，DO必须同步修改，这种修改将会影响到各层，这并不符合高内聚低耦合的原则。通过定义不同的DTO可以
     * 控制对不同系统暴露不同的属性，通过属性映射还可以实现具体的字段名称的隐藏。不同业务使用不同的模型，当一个业务发生变更需要修改字段时，
     * 不需要考虑对其它业务的影响，如果使用同一个对象则可能因为“不敢乱改”而产生很多不优雅的兼容性行为。
     *
     * 如果我们不愿意定义Param对象，使用Map来接收前端的参数，获取时如果采用JSON反序列化，则可能出现反序列化类型丢失问题。
     * 如果我们不使用Query对象而是Map对象来封装DAO的参数，设置和获取的key 很可能因为粗心导致设置和获取时的key不一致而出现BUG。
     *
     *
     * 2、实际开发中每种分层领域模型都会用到吗?
     * 上面只是给出一种参考，很多团队对部分分层模型的理解会有差异，实际的使用过程中根据自己团队的规模可以适当变通。比如有很多团队项目
     * 并不是特别大，为了降低复杂度，只用到了DT0、VO、DO三种分层领域模型。
     */
}
