package com.ww.HierarchicalDomainModel05;

/**
 * @author: Sun
 * @create: 2019-11-15 12:06
 * @version: v1.0
 */
public class HierarchicalDomainModel05 {

    /**
     *【参考】分层领域模型规约
     * DO (Data Object):此对象与数据库表结构一一对应，通过DAO层向上传输数据源对象。
     * DTO (Data Transfer Object): 数据传输对象，Service 或Manager向外传输的对象。
     * BO (Business Object):业务对象，由Service层输出的封装业务逻辑的对象。
     * AO (Application Object):应用对象，在Web层与Service 层之间抽象的复用对象模型，极为贴近展示层，复用度不高。
     * VO (View Object):显示层对象，通常是Web向模板渲染引擎层传输的对象。
     * Query: 数据查询对象，各层接收上层的查询请求。注意超过2个参数的查询封装，禁止使用Map类来传输。
     */

    /**
     * 整理+补充：
     * DTO(Data Transfer Object)：数据传输对象，通常将底层的数据聚合传给外部系统，它通常用作 Service 和 Manager 层向上层返回的对象。
     * 需要注意的是：如果作为分布式服务的参数或返回对象，通常要实现序列化接口。不提倡在 DTO 中写逻辑，强制不要在 RPC 返回对象的 DTO 中封装逻辑。
     *
     * Param/Query：查询参数对象，适用于各层，通常用作接受前端参数对象。Param 和 Query 的出现是为了避免使用 Map 作为接收参数的对象。
     * 在Service调用DAO时封装为Query对象传入，如果需要查询其他依赖则需要封装Param对象作为参数去查询。DAO 层一般插入和更新的参数对象使用
     * DO或Param, 查询参数一般使用Query，删除参数一般使用Param。
     *
     * BO(Business Object)：业务对象。该对象中通常包含业务逻辑。此对象在实际使用中有不同的理解，有的团队采用领域驱动设计，BO 含有属性和方法（具体可参考领域驱动设计的相关图书）；
     * 有的团队将 BO 当做 Service 返回给上层的 “专用 DTO” 使用；而有的团队则当做 Service 层内保存中间信息数据的 “DTO” 或者上下文对象来使用。
     *
     * VO(View Object)：视图对象，通常作为控制层通过JSON返回给前端然后前端渲染或者加载页面模板在后端进行填充。
     *
     * AO (Application Object)：应用对象。通常用在控制层和服务层之间。有些团队会将前端查询的属性和保存的属性几乎一致的对象封装为AO，
     * 如读取用户属性后传递给前端，用户在前端编辑了用户属性后传回后端。这种用法将AO用作Param和VO 或 Param和DTO的组合。
     *
     * 即使同一个接口，但是一个对内使用，一个对外暴露，尽量使用不同接口，定义不同的参数和返回值，从而避免因为修改内部或外部的数据结构而
     * 导致另外一个受到影响，这也是单一职责原则的要求。
     *
     *
     * 查询视图：
     * 前端或者其它服务将 Param 对象作为参数传给控制层或者对外服务接口，然后调用内部的服务类，服务类内部的中间数据和这些数据相关的逻辑可以封装为 BO ，
     * 比如根据 BO 多个属性判断是否符合某个条件。如果查询数据则封装为 Query 对象作为参数，如果需要查询其它依赖，则可以封装 Param 对象作为参数去查询。
     * DAO 层一般插入和更新的参数对象使用 DO 或 Param, 查询参数一般使用 Query，删除参数一般使用 Param。
     * @link https://img1.sycdn.imooc.com/5db65bbc0001a1da18681000.png
     *
     * 返回视图：
     * 数据访问层通常将数据封装为 DO 对象传给 Service 层，Manager 或 Client 层往往将查询结果封装为 DTO 传给 Service 层。
     * 通常内部服务层通过 DTO 往外传输数据。Controller 通常将 DTO 组装为前端需要的 VO 或者直接将 DTO 外传 。
     * RPC 服务接口将 DTO 直接返回或者重新封装为新的 DTO 返回给外部服务。
     * @link https://img1.sycdn.imooc.com/5db65bcd0001942c17701038.png
     */

    /**
     * 本节问题：
     * 1、为什么需要这些分层领域模型?
     * 答案：使用不同的分层领域模型能够让程序更加健壮、更容易拓展，可以降低系统各层的耦合度。
     *
     * 分层模型的优势只有在系统较大时才体现得更加明显。设想一下如果我们不想定义DTO和VO，直接将DO用到数据访问层、服务层、控制层和外部访问
     * 接口上。此时该表删除或者修改一个字段，DO必须同步修改，这种修改将会影响到各层，这并不符合高内聚低耦合的原则。通过定义不同的DTO可以
     * 控制对不同系统暴露不同的属性，通过属性映射还可以实现具体的字段名称的隐藏。不同业务使用不同的模型，当一个业务发生变更需要修改字段时，
     * 不需要考虑对其它业务的影响，如果使用同一个对象则可能因为“不敢乱改”而产生很多不优雅的兼容性行为。
     *
     * 如果我们不愿意定义Param对象，使用Map来接收前端的参数，获取时如果采用JSON反序列化，则可能出现反序列化类型丢失问题。
     * 如果我们不使用Query对象而是Map对象来封装DAO的参数，设置和获取的key 很可能因为粗心导致设置和获取时的key不一致而出现BUG。
     *
     *
     * 2、实际开发中每种分层领域模型都会用到吗?
     * 上面只是给出一种参考，很多团队对部分分层模型的理解会有差异，实际的使用过程中根据自己团队的规模可以适当变通。比如有很多团队项目
     * 并不是特别大，为了降低复杂度，只用到了DT0、VO、DO三种分层领域模型。
     */
}
