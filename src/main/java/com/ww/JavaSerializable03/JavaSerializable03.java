package com.ww.JavaSerializable03;

import java.io.Serializable;

/**
 * @author: Sun
 * @create: 2019-11-07 18:35
 * @version: v1.0
 */
public class JavaSerializable03 implements Serializable {

    /**
     *《手册》第9页“OOP规约”部分有一段关于序列化的约定
     *【强制】当序列化类新增属性时，请不要修改serialVersionUID字段，以避免反序列失败;如果完全不兼容升级，
     * 避免反序列化混乱，那么请修改serialVersionUID 值。
     * 说明:注意serialVersionUID值不一致会抛出序列化运行时异常。
     */

    /**
     * 本节问题：
     * 1、序列化和反序列化到底是什么?
     * 答案：把对象转换为字节序列存储于磁盘或者进行网络传输的过程称为对象的序列化。
     * 反序列化正好相反，是从网络传输过来的数据或此判断中读取序列化数据并转化成内存对象的过程。
     *
     * 2、为什么需要序列化和反序列化?
     * 大家可以回忆一下，平时都是如果将文字文件、图片文件、视频文件、软件安装包等传给小伙伴时，这些资源在计算机中存储的方式是怎样的。
     * 进而再思考，Java中的对象如果需要存储或者传输应该通过什么形式呢?
     *
     * 我们都知道，一个文件通常是一-个m个字节的序列: B0, B1, ... Bk, ... Bm-1。所有的I/O设备(例如网络、磁盘和终端)都被模型化为文件，
     * 而所有的输入和输出都被当作对应文件的读和写来执行。因此本质上讲，文本文件，图片、视频和安装包等文件底层都被转化为二进制字节流来传输的,
     * 对方得文件就需要对文件进行解析，因此就需要有能够根据不同的文件类型来解码出文件的内容的程序。
     *
     * 试想一个典型的场景:如果要实现Java远程方法调用，就需要将调用结果通过网路传输给调用方，如果调用方和服务提供方不在一台机器上
     * 就很难共享内存，就需要将Java对象进行传输。而想要将Java中的对象进行网络传输或存储到文件中，就需要将对象转化为二进制字节流，
     * 这就是所谓的序列化。存储或传输之后必然就需要将二进制流读取并解析成Java对象，这就是所谓的反序列化。
     *
     * 答案：为了方便存储到文件系统、数据库系统或网络传输等。
     *
     * 3、它的主要使用场景有哪些?
     * · 远程方法调用(RPC) 的框架里会用到序列化。
     * · 将对象存储到文件中时，需要用到序列化。
     * · 将对象存储到缓存数据库(如Redis) 时需要用到序列化。
     * · 通过序列化和反序列化的方式实现对象的深拷贝。
     *
     * 3、Java序列化常见的方案有哪些?
     * Java原生序列化、Hessian序列化、Kryo序列化、JSON序列化等。
     *
     * 4、各种常见序列化方案的区别有哪些?
     * · Java序列化的优点是:对对象的结构描述清晰，反序列化更安全。主要缺点是:效率低，序列化后的二进制流较大。
     * · Hession序列化二进制流较Java序列化更小，且序列化和反序列化耗时更短。但是父类和子类有相同类型属性时，由于先序列化子类再序列化父类，
     * 因此反序列化时子类的同名属性会被父类的值覆盖掉，开发时要特别注意这种情况。
     * · Kryo优点是:速度快、序列化后二进制流体积小、反序列化超快。但是缺点是:跨语言支持复杂。注册模式序列化更快，但是编程更加复杂。
     * · JSON序列化的优势在于可读性更强。主要缺点是:没有携带类型信息，只有提供了准确的类型信息才能准确地进行反序列化，这点也特别容易引发线上问题。
     *
     * 5、实际的业务开发中有哪些坑点?
     */

    /**
     * 包装类型不可强转，为什么包装类型不可强转？
     * Integer i = 100000;
     * Long l = (Long) i;
     * <p>
     * 并不是包装类型不可强转，而是只有具有子父类关系的类才可以相关强制转换。
     * 子类对象声明为父类类型后，可以通过强制转型转换为子类类型
     * 父类对象声明为父类类型后，不可以通过强制转换转换为子类型
     */

}
