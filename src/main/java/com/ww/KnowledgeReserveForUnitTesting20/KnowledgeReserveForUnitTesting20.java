package com.ww.KnowledgeReserveForUnitTesting20;

/**
 * @author: Sun
 * @create: 2019-12-05 12:15
 * @version: v1.0
 */
public class KnowledgeReserveForUnitTesting20 {

    /**
     * 单元测试作为编码质量的重要保障手段，是编码的一个非常重要的环节。
     * 《手册》第三部分对单元测试进行了描述，包括:
     * (1)单元测试必须遵守自动化、独立性和可重复性原则;
     * (2)单元测试的粒度一般是方法级别，最多也是类级别;
     * (3)核心业务、核心应用。核心模块的增量代码确保单元测试通过等。
     */

    /**
     * 本节问题：
     * (1)什么是单元测试?
     * PS：并不是使用能够编写单元测试的框架编写的测试就是单元测试
     * 单元测试:
     * 一个单元测试是一段代码，这段代码调用一个工作单元，并检验该工作单元的一个具体的最终结果。
     * 如果关于这个最终结果的假设是错误的，单元测试就失败了。
     * 一个单元测试的范围可以小到一个方法，大到一个类。
     * 集成测试：
     * 任何测试，如果它运行速度不快，结果不稳定，或者要用到被测试单元的一个或者多个真实依赖，就认为它是集成测试。
     * 集成测试是对一个工作单元进行测试，这个测试对被测试的工作单元没有完全控制，并使用工作单元的一个或多个真实依赖物，例如时间、网络、数据库、线程或随机数产生器等。
     *
     * 两者的主要联系和区别:
     * (1)集成测试和单元测试同样都很重要，都是验证系统功能的重要手段。
     * (2)但是集成测试运行通常更慢，很难编写，很难做到自动化，需要配置，通常一次测试的东西过多。
     * (3)集成测试会使用真实的依赖，而单元测试则把被测试的单元和其依赖隔离，以保证单元测试的高度稳定，还可以轻易控制和模拟被测试单元的行为方面。
     * 单元测试和集成测试最主要的区别之一就是测试中是否依赖“真实环境” 。
     *
     * (2)为什么要编写单元测试?
     * 答：单元测试可以让很多BUG在编码阶段就能够及时发现并解决，而不需要交给测试人员兜底，如果测试人员兜底失败，可能造成线上故障。有了单元测试作保障，
     * 我们还可以放心对函数进行重构，如果重构代码导致单元测试运行失败，则说明重构的代码有问题。长远来看，单元测试对编码的益处( 如提高代码质量和避免BUG)
     * 远比编写单元测试的投入所花费的代价要大的多。
     *
     * (3)什么是好的单元测试?
     * ①满足功能:被检验的函数或类的逻辑行为满足预期功能;
     * ②满足AIR原则:单元测试应该可以自动执行;单元测试的用例之间要保持彼此独立;单元测试可以重复执行。
     * ③优秀的单元测试还应该具有编写容易，运行快速的特点。
     * 不好的单元测试：通过打印语句输出结果，通过“肉眼”来测试，这样如果对被测试的类或函数做出修改而无法满足功能要求，单元测试也会运行通过，就失去了单元测试的意义。
     *
     * (4)单元测试的常用框架有哪些?
     * 常用的Java单元测试有: JUnit、 TestNG。
     * TestNG受JUnit和NUnit的启发，功能相似，但是比JUnit更强大。TestNG不只为单元测试而设计，其框架的设计目标是支持单元测试、公共能测试，端对端测试，集成测试等。
     *
     * 主流的Java mock框架有: Mockito, JMockit, Easy Mock。
     * Mockito简洁易用，有PowerMock拓展，允许静态函数测试，社区强大，对结果的验证和异常处理非常简洁、灵活。缺点是框架本身不支持static和private函数的mock。
     * JMockit简单易用;可以mock“一切”，包括final 类，final/private/static 函数，而其他mock框架往往只支持其中一部分;缺点是社区支持不够活跃，3个contributers 介乎只有一个在干活，学习曲线比较陡峭。
     * Easy Mock上手简单，文档清晰，同样的社区较小，导致更多人选择其它的mock框架。
     * 还有很多其他配合单元测试的框架，如强大的构造随机Java对象的Easy Random，构造随机字符串的Java Faker等。
     */

    /**
     * 加深对单元测试和集成测试的理解：
     * 单元测试是编写单元测试类，针对类级别的测试。比如使用Junit框架，针对一个类，写一个测试类，测试目标类的大部分主要方法。需要注意单元测试的级别是类。
     * 项目当中，类之间的依赖调用是很常见的事，如果你要测试一个类，而这个目标类又调用了另一个类，那么在测试时就没有遵守“在一个类范围内进行测试”，自然算不得单元测试。
     *
     * 假设A，B，C，D四个类之间存在上述的依赖关系，我们要测试类A，那么如何遵守“在类A的范围内测试”？
     * 这就是模拟框架要解决的问题了，通过模拟B和C，我们可以在测试A的时候，调用B和C的模拟对象，而不是实际的B和C。如果在测试时超脱一个类的范围，那就可以称为集成测试。
     * 如上面所述依赖关系，你可以测试类A，它会直接或间接调用其他三个类，这就可以叫做集成测试。你去测试类C，因为它会调用D，也可以称为集成测试。如果纯粹按照单元测试的概念，
     * 把这个工作代入到一个大型的项目，成百上千的类需要编写测试类，而且类之间的依赖需要编写模拟代码。这样的工作太过庞大，对项目来说应该是得不偿失的。应该识别核心代码，
     * 或者说是重要的代码，只对这些代码做精细的单元测试。除此之外，都通过集成测试来覆盖。集成测试时优先从最顶层开始，让测试自然流下来。然后根据代码测试覆盖报告，再进行补刀。
     *
     * Mock和Stub：
     * 在做单元测试的时候，需要屏蔽目标类的依赖，mock和stub就是这种操作涉及到的两个概念。在项目代码中，经常会涉及依赖多个外部资源的情况，
     * 比如数据库、微服务中的其他服务。这表示在测试的时候需要先做很多准备工作，比如准备数据库环境，比如先把依赖的服务run起来。
     * 另外，还需要考虑消除测试的副作用，以使测试具备幂等性。比如如果测试会修改数据库，那么是否会影响二次测试的结果，或者影响整个测试环境？
     * 对外部的资源依赖进行模拟，是一个有效的解决方案。即测试时不是真正的操作外部资源，而是通过自定义的代码进行模拟操作。我们可以对任何的依赖
     * 进行模拟，从而使测试的行为不需要任何准备工作或者不具备任何副作用。在这个大环境下，可以解释mock和stub的含义。
     *
     * Mock：当我们在测试时，如果只关心某个操作是否执行过，而不关心这个操作的具体行为，这种技术称为mock。比如我们测试的代码会执行发送邮件的操作，
     * 我们对这个操作进行mock；测试的时候我们只关心是否调用了发送邮件的操作，而不关心邮件是否确实发送出去了。
     *
     * Stub：当我们在测试时，关心操作的具体行为，或者操作的返回结果的时候，我们通过执行预设的操作来代替目标操作，或者返回预设的结果作为目标操作的返回结果。
     * 这种对操作的模拟行为称为stub（打桩）。比如我们测试代码的异常处理机制是否正常，我们可以对某处代码进行stub，让它抛出异常。再比如我们测试的代码
     * 需要向数据库插入一条数据，我们可以对插入数据的代码进行stub，让它始终返回1，表示数据插入成功。
     */
}
