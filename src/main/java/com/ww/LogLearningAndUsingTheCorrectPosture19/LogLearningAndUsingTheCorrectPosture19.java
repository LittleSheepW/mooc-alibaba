package com.ww.LogLearningAndUsingTheCorrectPosture19;

/**
 * @author: Sun
 * @create: 2019-12-04 09:51
 * @version: v1.0
 */
public class LogLearningAndUsingTheCorrectPosture19 {

    /**
     *《手册》第26到27页，提出了很多日志规约，其中比较重要的有:
     *【强制】应用中不要直接使用日志系统的API，而是应该依赖日志架构SLF4J中的API，使用门面模式的日志架构，有利于维护各个类的日志处理方式统一。
     *【强制】日志至少要保留15天，因为有些异常具备以"周"为频次的特点。
     *【强制】避免重复打印日志，浪费磁盘空间，务必在log4j.xml 中设置additivity=false。
     *【强制】异常信息应该包括两类信息:案发现场信息和异常堆栈信息等。
     *【强制】在日志输出时，字符串变量之间的拼接使用占位符的方式。   说明:因为String 字符串拼接会使用StringBuilder 的append()方式，有一定的性能损耗。使用占位符可以有效提高性能。
     *
     * --------------------------------------------------------推荐--------------------------------------------------------
     *【推荐】在自测或提测之后上线前一定要注意warn级别以上的日志，特别是error日志。通常我们会将ERROR日志专门输出到一个error.log文件。调试时通过tail -f error.log随时监控出现的错误日志。
     *【强制】不要用System.out.println 代替日志框架。
     * 以Tomcat为例，使用System.out.println 函数语句将信息输出到catalina.out 文件中，该文件会被清理，否则影响性能。文件的I0操作非常耗时，而该函数底层使用了
     * java.io.PrintStream#println(java.lang.Object)内部使用了同步代码块，非常影响性能。由于没有输出级别的概念，很多忘记删除的调试打印语句可能都被输出到输出文件中。
     * 如果是必须要打印日志的场景，请用日志框架打印。对于暂时性的本地或者测试服务器上排错，建议使用IDE的本地或者远程调试功能。在调试器中可以看到参数的值，看到调用栈，
     * 可以通过表达式查看变量的属性等，功能更加强大。
     *【强制】不要打印敏感信息，如果需要打印可以考虑对敏感信息脱敏处理。很多开发人员没有安全意识，将用户的密码和个人资料、商品的名称和价格等信息在未脱敏的情
     * 况下通过日志框架打印到日志文件中。这些都是很大的安全隐患，容易出现安全事故。因此不要打印敏感信息或者将敏感信息进行脱敏后再打印。
     *【推荐】除非业务需要，尽量不要打印大文本(含富文本)。如果要打印可以截取前M个字符。I/O操作非常耗时，在高并发场景下，如果同步打印大文本日志非常影响性能。
     * 另外，很多大文本对排查问题帮助不大，打印该信息的意义不大，因此尽量避免打印该内容或只截取一部分关键信息。如果公司内容有封装的相关注解，
     * 可以在大文本上加上忽略的注解。如果没有尽量避免调用JSON转字符串的函数将整个对象打印，可以重写toString方法忽略或截取大文本字段的一部分。
     *
     */

    /**
     * 本节问题：
     * 1、日志文件是什么？
     * 计算机领域，日志文件是记录发生在运行中的操作系统或其他软件中的事件或消息的文件。
     * 2、为什么要打印日志?
     * 打印日志的主要目的是为了监测系统状态，方便测试、排查问题。当测试时遇到和预计不符的情况，看日志是解决问题的最常用手段。
     * 设想一下如果没有日志，线上出现问题排查起来是不是更困难?
     * 很多监控系统都是通过监控日志来预警，很多线上问题通过日志来排查，很多测试人员依靠日志来辅助测试。
     * <p>
     * 3、为什么会重复打日志?
     * 答：一个logger可以被关联到多个appender上，对于logger的每个启用了的记录请求，都将被发送到logger里的全部appender及更高层次的appender中。
     * 换句话说：appender叠加地继承了logger 的层次等级。如果root 日志有一个控制台console，那么所有启动的日志至少都会输出到控制台中。
     * 如果root下还有一个叫L的logger，它含有-一个文件appender,那么L和L的子层次Logger的所有日志都将会打印到控制台和文件中。
     * 如何关闭累加行为？
     * 将logger的additivity 属性设置为false，则可以取消这种默认的appender累加行为。
     * <p>
     * 4、为什么推荐使用占位符方式打印日志？
     * 因为String字符串拼接会使用StringBuilder的append()方式，有一定的性能损耗。使用占位符的方式，底层会先使用判断逻辑，再去拼接字符串，
     * 从而避免了不必要的字符串拼接。 (可以log.debug("[v1:{}] [v2:{}] [v3:{}]", "s", "u", "n"); 走一遍DEBUG就看到了)
     * <p>
     * 5、不该在哪里打日志?
     * <p>
     * 6、该在哪些地方打日志呢?
     *【推荐】用切面或Filter 在dubbo或Controller层做切面来打印调用的参数、返回值和响应时间以及捕捉和打印异常日志。
     * 通过统一的日志，将参数和返回值，以及响应时间做切面，当出现问题时，可以极大地辅助我们排查，也能够帮助我们了解接口的响应情况。可以使用日志框架如CAT,做统一的traceld, 方便定位整条调用链路。
     *【推荐】在依赖的二方或三方接口的参数、返回值和异常处打印日志。依赖的二方和三方接口对接最容易出错，可以将其请求的参数和接口返回值以及异常信息等通过日志打印输出，方便分析和排查问题。
     * 一般也会使用切面统一打印，或者通过使用支持日志注解的框架来对某些接口的参数和返回值打印日志。
     *【推荐】在接收消息的地方打印日志。我们测试或者排查问题时，如果涉及到消息队列，最先要查的是有没有收到消息，因此接收到消息的地方打印日志比较有用。
     *【推荐】在定时任务的开始和结束的地方。和上面的条目很类似，在定时任务的开始和结束的地方打印日志也很重要。如果线上某个任务没有执行或者开始但是没有结束，可以通过日志快速排查问题。
     *【推荐】在异步任务的开始和结束的地方。异步任务如果出错，很难排查。在任务开始和结束的地方打印一些关键参数对排查问题有很大的帮助。在异步任务的异常捕捉地方打印日志也至关重要，将是分析问题的关键。
     *【推荐】面向测试打印日志。所谓的面向测试打印日志是指:方便测试人员测试开发人员代码而提供的测试。此日志的级别一般为DEBUG，-般仅在测试环境可用。有些测试人员并不会拉取你的代码或者编写单元测试，
     * 而只对你的编码进行功能性测试。此时，测试人员构造测试用例对你的接口进行验证时只能观察到接口的返回值，如果你能提供其中的核心计算函数的日志，将极大方便测试人员去验证功能。
     * <p>
     * 7、如果忘记打日志却着急排查问题怎么办?
     * 可以使用Arthas。
     *
     * <p>
     * 1、学习设计模式我们主要思考以下几个问题:
     * (1)为什么会出现这种设计模式?
     * 为了隐藏系统复杂性，向使用方提供统一的可以访问系统的接口。
     * <p>
     * (2)这种设计模式的核心思想是什么?
     * 门面设计模式在客户端和复杂的系统之间加一层，在这一层将调用的顺序和依赖的关系调整好。
     * <p>
     * (3)这种设计模式的使用场景有哪些?
     * 为复杂的子系统提供外界访问的模块。
     * 预防低水平的开发人员带来的风险。
     * <p>
     * (4)这种设计模式的优缺点有哪些?
     * 优点:减少了系统的相互依赖，提高了灵活性和安全性。
     * 缺点:不符合开闭原则，如果接口要修改无法通过继承和覆写来解决，只能修改门面代码，影响面比较大。
     * <p>
     * 2、为什么在应用中不要直接使用日志系统的API，而是应该依赖日志架构SLF4J中的API?
     * 答:使用SLF4J编写代码，开发人员不需要关注不同的日志框架的差异，各日志框架对SLF4J做适配。由于没有具体依赖某个日志框架，如果系统出于安全、
     * 性能等原因想更换另外一个新的日志框架就轻而易举。
     */

}
